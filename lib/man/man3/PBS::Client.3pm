.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PBS::Client 3pm"
.TH PBS::Client 3pm "2014-05-20" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PBS::Client \- Perl interface to submit jobs to Portable Batch System (PBS).
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Load this module
\&    use PBS::Client;
\&    
\&    # Create a client object
\&    my $client = PBS::Client\->new();
\&    
\&    # Specify the job
\&    my $job = PBS::Client::Job\->new(
\&        queue => <job queue>,
\&        mem   => <memory requested>,
\&        .....
\&        cmd   => <command list in array reference>
\&    );
\&    
\&    # Optionally, re\-organize the commands to a number of batched
\&    $job\->pack(numQ => <number of batch>);
\&    
\&    # Submit the job
\&    $client\->qsub($job);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a Perl interface to submit jobs to the Portable Batch
System (\s-1PBS\s0) server. \s-1PBS\s0 is a software allocating recources of a network to
batch jobs. This module lets you submit jobs on the fly.
.PP
To submit jobs by PBS::Client, you need to prepare two objects: the client
object and the job object. The client object connects to the server and submits
jobs (described by the job object) by the method \f(CW\*(C`qsub\*(C'\fR.
.PP
The job object specifies various properties of a job (or a group of jobs).
Properties that can be specified includes job name, \s-1CPU\s0 time, memory, priority,
job inter-dependency and many others.
.PP
This module attempts to adopt the same philosophy of Perl, of which it tries
to understand what you want to do and gives you the least surprise. Therefore,
you usually can do the same thing with more than one way. This is also a
reason that makes this document lengthy.
.SH "SIMPLE USAGE"
.IX Header "SIMPLE USAGE"
Three basic steps:
.IP "1. Create a client object, e.g.," 4
.IX Item "1. Create a client object, e.g.,"
.Vb 1
\&    my $client = PBS::Client\->new();
.Ve
.IP "2. Create a job object and specify the commands to be submitted. E.g., to submit jobs to get the current working directory and current date-time:" 4
.IX Item "2. Create a job object and specify the commands to be submitted. E.g., to submit jobs to get the current working directory and current date-time:"
.Vb 1
\&    my $job = PBS::Client::Job\->new(cmd => [\*(Aqpwd\*(Aq, \*(Aqdate\*(Aq]);
.Ve
.ie n .IP "3. Use the ""qsub()"" method of the client object to submit the jobs, e.g.," 4
.el .IP "3. Use the \f(CWqsub()\fR method of the client object to submit the jobs, e.g.," 4
.IX Item "3. Use the qsub() method of the client object to submit the jobs, e.g.,"
.Vb 1
\&    $client\->qsub($job);
.Ve
.PP
There are other methods and options of the client object and job object. Most
of the options are optional. When omitted, default values would be used. The
only must option is \f(CW\*(C`cmd\*(C'\fR which tells the client object what commands to be
submitted.
.SH "CLIENT OBJECT METHODS"
.IX Header "CLIENT OBJECT METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 3
\&    $pbs = PBS::Client\->new(
\&        server => $server       # PBS server name (optional)
\&    );
.Ve
.PP
Client object is created by the \f(CW\*(C`new\*(C'\fR method. The name of the \s-1PBS\s0 server can
by optionally supplied. If it is omitted, the default server is assumed.
.SS "\fIqsub()\fP"
.IX Subsection "qsub()"
Job (as a job object) is submitted to \s-1PBS\s0 by the method \f(CW\*(C`qub\*(C'\fR.
.PP
.Vb 1
\&    my $pbsid = $pbs\->qsub($job_object);
.Ve
.PP
An array reference of \s-1PBS\s0 job \s-1ID\s0 would be returned.
.SH "JOB OBJECT METHODS"
.IX Header "JOB OBJECT METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 7
\&     $job = PBS::Client::Job\->new(
\&         # Job declaration options
\&         wd        => $wd,              # working directory, default: cwd
\&         name      => $name,            # job name, default: pbsjob.sh
\&         script    => $script,          # job script name, default: pbsjob.sh
\&         shell     => $shell,           # shell path, default: /bin/sh
\&         account   => $account,         # account string
\&     
\&         # Resources options
\&         partition => $partition,       # partition
\&         queue     => $queue,           # queue
\&         begint    => $begint,          # beginning time
\&         host      => $host,            # host used to execute
\&         nodes     => $nodes,           # execution nodes, default: 1
\&         ppn       => $ppn,             # process per node
\&         pri       => $pri,             # priority
\&         nice      => $nice,            # nice value
\&         mem       => $mem,             # requested total memory
\&         pmem      => $pmem,            # requested per\-process memory
\&         vmem      => $vmem,            # requested total virtual memory
\&         pvmem     => $pvmem,           # requested per\-process virtual memory
\&         cput      => $cput,            # requested total CPU time
\&         pcput     => $pcput,           # requested per\-process CPU time
\&         wallt     => $wallt,           # requested wall time
\&     
\&         # IO options
\&         stagein   => $stagein,         # files staged in
\&         stageout  => $stageout,        # files staged out
\&         ofile     => $ofile,           # standard output file
\&         efile     => $efile,           # standard error file
\&         maillist  => $mails,           # mail address list
\&         mailopt   => $options,         # mail options, combination of a, b, e
\&     
\&         # Command options
\&         vars      => {%name_values},   # name\-value of env variables
\&         cmd       => [@commands],      # command to be submitted
\&         prev      => {                 # job before
\&                       ok    => $job1,  # successful job before this job
\&                       fail  => $job2,  # failed job before this job
\&                       start => $job3,  # started job before this job
\&                       end   => $job4,  # ended job before this job
\&                      },
\&         next      => {                 # job follows
\&                       ok    => $job5,  # next job after this job succeeded
\&                       fail  => $job6,  # next job after this job failed
\&                       start => $job7,  # next job after this job started
\&                       end   => $job8,  # next job after this job ended
\&                      },
\&     
\&         # Job tracer options
\&         tracer    => $on,              # job tracer, either on / off (default)
\&         tfile     => $tfile,           # tracer report file
\&     );
.Ve
.PP
Two points may be noted:
.ie n .IP "1. Except ""cmd"", all attributes are optional." 4
.el .IP "1. Except \f(CWcmd\fR, all attributes are optional." 4
.IX Item "1. Except cmd, all attributes are optional."
.PD 0
.IP "2. All attributes can also be modified by methods, e.g.," 4
.IX Item "2. All attributes can also be modified by methods, e.g.,"
.PD
.Vb 1
\&    $job = PBS::Client::Job\->new(cmd => [@commands]);
.Ve
.Sp
is equivalent to
.Sp
.Vb 2
\&    $job = PBS::Client::Job\->new();
\&    $job\->cmd([@commands]);
.Ve
.PP
\fIJob Declaration Options\fR
.IX Subsection "Job Declaration Options"
.PP
wd
.IX Subsection "wd"
.PP
Full path of the working directory, i.e. the directory where the command(s) is
executed. The default value is the current working directory.
.PP
name
.IX Subsection "name"
.PP
Job name. It can have 15 or less characters. It cannot contain space and the
first character must be alphabetic. If not specified, it would follow the
script name.
.PP
script
.IX Subsection "script"
.PP
Filename prefix of the job script to be generated. The \s-1PBS\s0 job \s-1ID\s0 would be
appended to the filename as the suffix.
.PP
Example: \f(CW\*(C`script => test.sh\*(C'\fR would generate a job script like
\&\fItest.sh.12345\fR if the job \s-1ID\s0 is '12345'.
.PP
The default value is \f(CW\*(C`pbsjob.sh\*(C'\fR.
.PP
shell
.IX Subsection "shell"
.PP
Thsi option lets you to set the shell path. The default path is \f(CW\*(C`/bin/sh\*(C'\fR.
.PP
account
.IX Subsection "account"
.PP
Account string. This is meaningful if you need to which account you are using
to submit the job.
.PP
\fIResources Options\fR
.IX Subsection "Resources Options"
.PP
partition
.IX Subsection "partition"
.PP
Partition name. This is meaningful only for the clusters with partitions. If it
is omitted, default value will be assumed.
.PP
queue
.IX Subsection "queue"
.PP
Queue of which jobs are submitted to. If omitted, default queue would be used.
.PP
begint (Experimental)
.IX Subsection "begint (Experimental)"
.PP
The date-time at which the job begins to queue. The format is either
\&\*(L"[[[[\s-1CC\s0]YY]MM]DD]hhmm[.SS]\*(R" or \*(L"[[[[\s-1CC\s0]YY\-]MM\-]DD] hh:mm[:SS]\*(R".
.PP
Example:
.PP
.Vb 3
\&    $job\->begint(\*(Aq200605231448.33\*(Aq);
\&    # or equilvalently
\&    $job\->begint(\*(Aq2006\-05\-23 14:48:33\*(Aq);
.Ve
.PP
This feature is in Experimental phase. It may not be supported in later
versions.
.PP
host
.IX Subsection "host"
.PP
You can specify the host on which the job will be run.
.PP
nodes
.IX Subsection "nodes"
.PP
Nodes used. It can be an integer (declaring number of nodes used), string
(declaring which nodes are used), array reference (declaring which nodes are
used), and hash reference (declaring which nodes, and how many processes of
each node are used).
.PP
Examples:
.IP "\(bu" 4
Integer
.Sp
.Vb 1
\&    nodes => 3
.Ve
.Sp
means that three nodes are used.
.IP "\(bu" 4
String / array reference
.Sp
.Vb 2
\&    # string representation
\&    nodes => "node01 + node02"
\&    
\&    # array representation
\&    nodes => ["node01", "node02"]
.Ve
.Sp
means that nodes \*(L"node01\*(R" and \*(L"node02\*(R" are used.
.IP "\(bu" 4
Hash reference
.Sp
.Vb 1
\&    nodes => {node01 => 2, node02 => 1}
.Ve
.Sp
means that \*(L"node01\*(R" is used with 2 processes, and \*(L"node02\*(R" with 1 processes.
.PP
ppn
.IX Subsection "ppn"
.PP
Maximum number of processes per node. The default value is 1.
.PP
pri
.IX Subsection "pri"
.PP
Priority of the job in queueing. The higher the priority is, the shorter is the
queueing time. Priority must be an integer between \-1024 to +1023 inclusive.
The default value is 0.
.PP
nice
.IX Subsection "nice"
.PP
Nice value of the job during execution. It must be an integer between \-20
(highest priority) to 19 (lowest). The default value is 10.
.PP
mem
.IX Subsection "mem"
.PP
Maximum physical memory used by all processes. Unit can be b (bytes), w
(words), kb, kw, mb, mw, gb or gw. If it is omitted, default value will be
used. Please see also pmem, vmem and pvmem.
.PP
pmem
.IX Subsection "pmem"
.PP
Maximum per-process physical memory. Unit can be b (bytes), w (words), kb, kw,
mb, mw, gb or gw. If it is omitted, default value will be used. Please see also
mem, vmem and pvmem.
.PP
vmem
.IX Subsection "vmem"
.PP
Maximum virtual memory used by all processes. Unit can be b (bytes), w (words),
kb, kw, mb, mw, gb or gw. If it is omitted, default value will be used. Please
see also mem, pmem and pvmem.
.PP
pvmem
.IX Subsection "pvmem"
.PP
Maximum virtual memory per processes. Unit can be b (bytes), w (words), kb, kw,
mb, mw, gb or gw. If it is omitted, default value will be used. Please see also
mem, pmem and vmem.
.PP
cput
.IX Subsection "cput"
.PP
Maximum amount of total \s-1CPU\s0 time used by all processes. Values are specified in
the form [[hours:]minutes:]seconds[.milliseconds].
.PP
Example:
.PP
.Vb 1
\&    $job\->cput(\*(Aq00:30:00\*(Aq);
.Ve
.PP
refers to 30 minutes of \s-1CPU\s0 time. Please see also pcput and wallt.
.PP
pcput
.IX Subsection "pcput"
.PP
Maximum amount of per-process \s-1CPU\s0 time. Values are specified in the form
[[hours:]minutes:]seconds[.milliseconds]. Please see also cput and wallt.
.PP
wallt
.IX Subsection "wallt"
.PP
Maximum amount of wall time used. Values are specified in the form
[[hours:]minutes:]seconds[.milliseconds]. Please see also cput and pcput.
.PP
\fI\s-1IO\s0 Options\fR
.IX Subsection "IO Options"
.PP
stagein
.IX Subsection "stagein"
.PP
Specify which files are need to stage (copy) in before the job starts. It may
be a string, array reference or hash reference. For example, to stage in
\&\fIfrom01.file\fR and \fIfrom02.file\fR in the remote host \*(L"fromMachine\*(R" and rename
\&\fIto01.file\fR and \fIto02.file\fR respectively, following three representation are
equilvalent:
.IP "\(bu" 4
String
.Sp
.Vb 2
\&    stagein => "to01.file@fromMachine:from01.file,".
\&               "to02.file@fromMachine:from02.file"
.Ve
.IP "\(bu" 4
Array
.Sp
.Vb 2
\&    stagein => [\*(Aqto01.file@fromMachine:from01.file\*(Aq,
\&                \*(Aqto02.file@fromMachine:from02.file\*(Aq]
.Ve
.IP "\(bu" 4
Hash
.Sp
.Vb 2
\&    stagein => {\*(AqfromMachine:from01.file\*(Aq => \*(Aqto01.file\*(Aq,
\&                \*(AqfromMachine:from02.file\*(Aq => \*(Aqto02.file\*(Aq}
.Ve
.PP
stageout
.IX Subsection "stageout"
.PP
Specify which files are need to stage (copy) out after the job finishs. Same as
\&\f(CW\*(C`stagein\*(C'\fR, it may be string, array reference or hash reference.
.PP
Examples:
.IP "\(bu" 4
String
.Sp
.Vb 2
\&    stageout => "from01.file@toMachine:to01.file,".
\&                "from02.file@toMachine:to02.file"
.Ve
.IP "\(bu" 4
Array
.Sp
.Vb 2
\&    stageout => [\*(Aqfrom01.file@toMachine:to01.file\*(Aq,
\&                 \*(Aqfrom02.file@toMachine:to02.file\*(Aq]
.Ve
.IP "\(bu" 4
Hash
.Sp
.Vb 2
\&    stageout => {\*(Aqfrom01.file\*(Aq => \*(AqtoMachine:to01.file\*(Aq,
\&                 \*(Aqfrom02.file\*(Aq => \*(AqtoMachine:to02.file\*(Aq}
.Ve
.PP
ofile
.IX Subsection "ofile"
.PP
Path of the file for standard output. The default filename is like
\&\fIjobName.o12345\fR if the job name is 'jobName' and its \s-1ID\s0 is '12345'. Please
see also efile.
.PP
efile
.IX Subsection "efile"
.PP
Path of the file for standard error. The default filename is like
\&\fIjobName.e12345\fR if the job name is 'jobName' and its \s-1ID\s0 is '12345'. Please
see also ofile.
.PP
maillist
.IX Subsection "maillist"
.PP
This option declares who (the email address list) will receive mail about the
job. The default is the job owner. The situation that the server will send
email is set by the \f(CW\*(C`mailopt\*(C'\fR option shown below.
.PP
For more than one email addresses, \f(CW\*(C`maillist\*(C'\fR can be either a comma separated
string or a array reference.
.PP
mailopt
.IX Subsection "mailopt"
.PP
This option declares under what situation will the server send email. It can be
any combination of \f(CW\*(C`a\*(C'\fR, which indicates that mail will be sent if the job is
aborted, \f(CW\*(C`b\*(C'\fR, indicating that mail will be sent if the job begins to run, and
\&\f(CW\*(C`e\*(C'\fR, which indicates that mail will be sent if the job finishes. For example,
.PP
.Vb 3
\&    mailopt => "b, e"
\&    # or lazily,
\&    mailopt => "be"
.Ve
.PP
means that mail will be sent when the job begins to run and finishes.
.PP
The default is \f(CW\*(C`a\*(C'\fR.
.PP
\fICommand Options\fR
.IX Subsection "Command Options"
.PP
vars
.IX Subsection "vars"
.PP
This option lets you expand the environment variables exported to the job. It
can be a string, array reference or hash reference.
.PP
Example: to export the following variables to the job:
.PP
.Vb 4
\&    A
\&    B = b
\&    C
\&    D = d
.Ve
.PP
you may use one of the following ways:
.IP "\(bu" 4
String
.Sp
.Vb 1
\&    vars => "A, B=b, C, D=d",
.Ve
.IP "\(bu" 4
Array reference
.Sp
.Vb 1
\&    vars => [\*(AqA\*(Aq, \*(AqB=b\*(Aq, \*(AqC\*(Aq, \*(AqD=d\*(Aq]
.Ve
.IP "\(bu" 4
Hash reference
.Sp
.Vb 1
\&    vars => {A => \*(Aq\*(Aq, B => \*(Aqb\*(Aq, C => \*(Aq\*(Aq, D => \*(Aqd\*(Aq}
.Ve
.IP "\(bu" 4
Mixed
.Sp
.Vb 1
\&    vars => [\*(AqA\*(Aq, \*(AqC\*(Aq, {B => \*(Aqb\*(Aq, D => \*(Aqd\*(Aq}]
.Ve
.PP
cmd
.IX Subsection "cmd"
.PP
Command(s) to be submitted. It can be an array (2D or 1D) reference or a
string. For 2D array reference, each row would be a separate job in \s-1PBS\s0, while
different elements of the same row are commands which would be executed one by
one in the same job.  For 1D array, each element is a command which would be
submitted separately to \s-1PBS\s0. If it is a string, it is assumed that the string
is the only one command which would be executed.
.PP
Examples:
.IP "\(bu" 4
2D array reference
.Sp
.Vb 2
\&    cmd => [["./a1.out"],
\&            ["./a2.out" , "./a3.out"]]
.Ve
.Sp
means that \f(CW\*(C`a1.out\*(C'\fR would be excuted as one \s-1PBS\s0 job, while \f(CW\*(C`a2.out\*(C'\fR and
\&\f(CW\*(C`a3.out\*(C'\fR would be excuted one by one in another job.
.IP "\(bu" 4
1D array reference
.Sp
.Vb 1
\&    cmd => ["./a1.out", "./a2.out"]
.Ve
.Sp
means that \f(CW\*(C`a1.out\*(C'\fR would be executed as one \s-1PBS\s0 job and \f(CW\*(C`a2.out\*(C'\fR would be
another. Therefore, this is equilvalent to
.Sp
.Vb 1
\&    cmd => [["./a1.out", "./a2.out"]]
.Ve
.IP "\(bu" 4
String
.Sp
.Vb 1
\&    cmd => "./a.out"
.Ve
.Sp
means that the command \f(CW\*(C`a.out\*(C'\fR would be executed. Equilvalently, it can be
.Sp
.Vb 3
\&    cmd => [["./a.out"]]  # as a 2D array
\&    # or
\&    cmd => ["./a.out"]    # as a 1D array.
.Ve
.PP
prev
.IX Subsection "prev"
.PP
Hash reference which declares the job(s) executed beforehand. The hash can have
four possible keys: \f(CW\*(C`start\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`ok\*(C'\fR and \f(CW\*(C`fail\*(C'\fR. \f(CW\*(C`start\*(C'\fR declares
job(s) which has started execution. \f(CW\*(C`end\*(C'\fR declares job(s) which has already
ended. \f(CW\*(C`ok\*(C'\fR declares job(s) which has finished successfully. \f(CW\*(C`fail\*(C'\fR declares
job(s) which failed. Please see also next.
.PP
Example:
.PP
.Vb 1
\&    $job1\->prev({ok => $job2, fail => $job3})
.Ve
.PP
means that \f(CW$job1\fR is executed only after \f(CW$job2\fR exits normally and \f(CW\*(C`job3\*(C'\fR
exits with error.
.PP
next
.IX Subsection "next"
.PP
Hash reference which declares the job(s) executed later. The hash can have four
possible keys: \f(CW\*(C`start\*(C'\fR, \f(CW\*(C`end\*(C'\fR, \f(CW\*(C`ok\*(C'\fR and \f(CW\*(C`fail\*(C'\fR. \f(CW\*(C`start\*(C'\fR declares job(s)
after started execution. \f(CW\*(C`end\*(C'\fR declares job(s) after finished execution. \f(CW\*(C`ok\*(C'\fR
declares job(s) after finished successfully. \f(CW\*(C`fail\*(C'\fR declares job(s) after
failure. Please see also prev.
.PP
Example:
.PP
.Vb 1
\&    $job1\->next({ok => $job2, fail => $job3})
.Ve
.PP
means that \f(CW$job2\fR would be executed after \f(CW$job1\fR exits normally, and
otherwise \f(CW\*(C`job3\*(C'\fR would be executed instead.
.PP
\fIJob Tracer Options\fR
.IX Subsection "Job Tracer Options"
.PP
tracer (Experimental)
.IX Subsection "tracer (Experimental)"
.PP
Trace when and where the job was executing. It takes value of either on or off
(default). If it is turned on, an extra tracer report file would be generated.
It records when the job started, where it ran, when it finished and how long it
used.
.PP
This feature is in Experimental phase. It may not be supported in later
versions.
.PP
tfile (Experimental)
.IX Subsection "tfile (Experimental)"
.PP
Path of the tracer report file. The default filename is like \fIjobName.t12345\fR
if the job name is 'jobName' and its \s-1ID\s0 is '12345'. Please see also ofile
and efile.
.PP
This feature is in Experimental phase. It may not be supported in later
versions.
.SS "pbsid"
.IX Subsection "pbsid"
Return the \s-1PBS\s0 job \s-1ID\s0(s) of the job(s). It returns after the job(s) has
submitted to the \s-1PBS\s0. The returned value is an integer if \f(CW\*(C`cmd\*(C'\fR is a string.
If \f(CW\*(C`cmd\*(C'\fR is an array reference, the reference of the array of \s-1ID\s0 will be
returned. For example,
.PP
.Vb 1
\&    $pbsid = $job\->pbsid;
.Ve
.SS "\fIpack()\fP"
.IX Subsection "pack()"
\&\f(CW\*(C`pack\*(C'\fR is used to rearrange the commands among different queues (\s-1PBS\s0 jobs).
Two options, which are \f(CW\*(C`numQ\*(C'\fR and \f(CW\*(C`cpq\*(C'\fR can be set. \f(CW\*(C`numQ\*(C'\fR specifies number
of jobs that the commands will be distributed. For example,
.PP
.Vb 1
\&    $job\->pack(numQ => 8);
.Ve
.PP
distributes the commands among 8 jobs. On the other hand, the \f(CW\*(C`cpq\*(C'\fR
(abbreviation of \fBc\fRommand \fBp\fRer \fBq\fRueue) option rearranges the commands
such that each job would have specified commands. For example,
.PP
.Vb 1
\&    $job\->pack(cpq => 8);
.Ve
.PP
packs the commands such that each job would have 8 commands, until no command
left.
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
Job objects can be copied by the \f(CW\*(C`copy\*(C'\fR method:
.PP
.Vb 1
\&    my $new_job = $old_job\->copy;
.Ve
.PP
The new job object (\f(CW$new_job\fR) is identical to, but independent of the
original job object (\f(CW$old_job\fR).
.PP
\&\f(CW\*(C`copy\*(C'\fR can also specify number of copies to be generated. For example,
.PP
.Vb 1
\&    my @copies = $old_job\->copy(3);
.Ve
.PP
makes three identical copies.
.PP
Hence, the following two statements are the same:
.PP
.Vb 2
\&    my $new_job = $old_job\->copy;
\&    my ($new_job) = $old_job\->copy(1);
.Ve
.SH "SCENARIOS"
.IX Header "SCENARIOS"
.IP "1. Submit a Single Command" 4
.IX Item "1. Submit a Single Command"
You want to run \f(CW\*(C`a.out\*(C'\fR of current working directory in the default queue:
.Sp
.Vb 5
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    my $job = PBS::Client::Job\->new(
\&        cmd   => \*(Aq./a.out\*(Aq,
\&    );
.Ve
.IP "2. Submit a List of Commands" 4
.IX Item "2. Submit a List of Commands"
You need to submit a list of commands to \s-1PBS\s0. They are stored in the Perl array
\&\f(CW@jobs\fR. You want to execute them one by one in a single \s-1CPU:\s0
.Sp
.Vb 6
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    my $job = PBS::Client::Job\->new(
\&        cmd => [\e@jobs],
\&    );
\&    $pbs\->qsub($job);
.Ve
.IP "3. Submit Multiple Lists" 4
.IX Item "3. Submit Multiple Lists"
You have 3 groups of commands, stored in \f(CW@jobs_a\fR, \f(CW@jobs_b\fR, \f(CW@jobs_c\fR.
You want to execute each group in different \s-1CPU:\s0
.Sp
.Vb 10
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    my $job = PBS::Client::Job\->new(
\&        cmd => [
\&                \e@jobs_a,
\&                \e@jobs_b,
\&                \e@jobs_c,
\&               ],
\&    );
\&    $pbs\->qsub($job);
.Ve
.IP "4. Rearrange Commands (Specifying Number of Queues)" 4
.IX Item "4. Rearrange Commands (Specifying Number of Queues)"
You have 3 groups of commands, stored in \f(CW@jobs_a\fR, \f(CW@jobs_b\fR, \f(CW@jobs_c\fR.
You want to re-organize them to 4 batches:
.Sp
.Vb 11
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    my $job = PBS::Client::Job\->new(
\&        cmd => [
\&                \e@jobs_a,
\&                \e@jobs_b,
\&                \e@jobs_c,
\&               ],
\&    );
\&    $job\->pack(numQ => 4);
\&    $pbs\->qsub($job);
.Ve
.IP "5. Rearrange Commands (Specifying Commands Per Queue)" 4
.IX Item "5. Rearrange Commands (Specifying Commands Per Queue)"
You have 3 batches of commands, stored in \f(CW@jobs_a\fR, \f(CW@jobs_b\fR, \f(CW@jobs_c\fR.
You want to re-organize them such that each batch has 4 commands:
.Sp
.Vb 11
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    my $job = PBS::Client::Job\->new(
\&        cmd => [
\&                \e@jobs_a,
\&                \e@jobs_b,
\&                \e@jobs_c,
\&               ],
\&    );
\&    $job\->pack(cpq => 4);
\&    $pbs\->qsub($job);
.Ve
.IP "6. Customize resource" 4
.IX Item "6. Customize resource"
You want to customize the requested resources rather than using the default
ones:
.Sp
.Vb 2
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    
\&    my $job = PBS::Client::Job\->new(
\&        account   => <account name>,
\&        partition => <partition name>,
\&        queue     => <queue name>,
\&        wd        => <working directory of the commands>,
\&        name      => <job name>,
\&        script    => <name of the generated script>,
\&        pri       => <priority>,
\&        mem       => <memory>,
\&        cput      => <maximum CPU time>,
\&        wallt     => <maximum wall clock time>,
\&        prologue  => <prologue script>,
\&        epilogue  => <epilogue script>,
\&        cmd       => <commands to be submitted>,
\&    );
\&    $pbs\->qsub($job);
.Ve
.IP "7. Job dependency" 4
.IX Item "7. Job dependency"
You want to run \f(CW\*(C`a1.out\*(C'\fR. Then run \f(CW\*(C`a2.out\*(C'\fR if \f(CW\*(C`a1.out\*(C'\fR finished
successfully; otherwise run \f(CW\*(C`a3.out\*(C'\fR and \f(CW\*(C`a4.out\*(C'\fR.
.Sp
.Vb 5
\&    use PBS::Client;
\&    my $pbs = PBS::Client\->new;
\&    my $job1 = PBS::Client::Job\->new(cmd => "./a1.out");
\&    my $job2 = PBS::Client::Job\->new(cmd => "./a2.out");
\&    my $job3 = PBS::Client::Job\->new(cmd => ["./a3.out", "./a4.out"]);
\&    
\&    $job1\->next({ok => $job2, fail => $job3});
\&    $pbs\->qsub($job1);
.Ve
.ie n .SH "SCRIPT ""RUN"""
.el .SH "SCRIPT ``RUN''"
.IX Header "SCRIPT RUN"
If you want to execute a single command, you need not write script.  The
simplest way is to use the script \fIrun\fR in this package. For example,
.PP
.Vb 1
\&    run "./a.out \-\-debug > a.dat"
.Ve
.PP
would submit the job executing the command \*(L"a.out\*(R" with option \*(L"\-\-debug\*(R", and
redirect the output to the file \*(L"a.dat\*(R".
.PP
The options of the job object, such as the resource requested can be edited by
.PP
.Vb 1
\&    run \-e
.Ve
.PP
The more detail manual can be viewed by
.PP
.Vb 1
\&    run \-m
.Ve
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Data::Dumper, File::Temp
.SH "TEST"
.IX Header "TEST"
This module has only been tested with OpenPBS in Linux. However, it was written
to fit in as many Unix-like \s-1OS\s0 with \s-1PBS\s0 installed as possible.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.ie n .IP "1. This module requires the \s-1PBS\s0 command line tools, especially ""qsub"" and ""qstat""." 4
.el .IP "1. This module requires the \s-1PBS\s0 command line tools, especially \f(CWqsub\fR and \f(CWqstat\fR." 4
.IX Item "1. This module requires the PBS command line tools, especially qsub and qstat."
.PD 0
.IP "2. This module requires that all nodes can execute Bourne shell scripts, and that the shell path are the same." 4
.IX Item "2. This module requires that all nodes can execute Bourne shell scripts, and that the shell path are the same."
.IP "3. Jobs with inter-dependency cannot be submitted to the non-default server. This limitation will be removed soon, hopefully." 4
.IX Item "3. Jobs with inter-dependency cannot be submitted to the non-default server. This limitation will be removed soon, hopefully."
.PD
.PP
Please email to kwmak@cpan.org for bug report or other suggestions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1PBS\s0 offical website http://www.openpbs.com,
.PP
\&\s-1PBS\s0
.SH "AUTHOR(S)"
.IX Header "AUTHOR(S)"
Ka-Wai Mak <kwmak@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006\-2007, 2010\-2011 Ka-Wai Mak. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
